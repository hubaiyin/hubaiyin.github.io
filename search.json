[{"title":"路由","date":"2023-03-29T13:03:39.000Z","url":"/2023/03/29/%E8%B7%AF%E7%94%B1/","categories":[["undefined",""]],"content":"路由理解：一个路由（route）就是一组映射关系（key-value），多个路由需要路由器（router）进行管理 前端路由：key是路径，value是组件 基本使用 安装vue-router，命令：npm i vue-router@3 应用插件：Vue.use(VueRouter) 编写router配置项： 编写main.js App.vue 几个注意点 路由组件通常放在 pages 文件夹（此处我没有放），一般组件通常存放在 components 文件夹 通过切换，被“隐藏”的路由组件，默认是被销毁掉的，需要的时候再去挂载 每个组件都有自己的 $route 属性，里面存储着自己的路由信息 整个应用只有一个 router，可以通过组件的 $router 属性获取到 嵌套路由（多级路由） 配置路由规则，使用children配置项： 跳转（要写完整路径） 路由的query参数（路由传参） 传递参数 接收参数 命名路由 作用：可以简化路由的跳转 如何使用 给路由命名 简化跳转 路由的params参数 配置路由，声明并接收params参数 传递参数 &#x2F;&#x2F;特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！ 接收参数 路由的props配置 作用：让路由组件更方便的收到参数 &lt;router-link&gt;的push和replace属性 作用：控制由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别是push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时默认为push 如何开启replace模式：&lt;router-link replace&gt;News&lt;/router-link 编程式路由导航 作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更加灵活 具体编码： 缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁 具体编码： 两个新的生命周期钩子 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态 具体名字： activated路由组件被激活时触发 deactivated路由组件失活时触发 路由守卫（重要） 作用：对路由进行权限控制 分类：全局守卫、独享守卫、组件内守卫 全局守卫： 独享守卫： 组件内守卫： 路由器的两种工作模式 对于一个url来说，什么是hash值？———#及其后面的内容就是hash值 hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器 hash模式： 地址永远带着#号，不美观 若以后将地址通过第三方收集app分享，若app校验严格，则地址会被标记为不合法 兼容性较好 history模式： 地址干净，美观 兼容性和hash模式相比略差 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题 如何切换 "},{"title":"slot插槽","date":"2023-03-29T06:40:24.000Z","url":"/2023/03/29/slot%E6%8F%92%E6%A7%BD/","categories":[["undefined",""]],"content":"slot插槽也是一种组件间通信的方式，让父组件可以往子组件指定位置插入html结构在你的组件标签中书写的标签体Vue不知道该往哪里放，所以不会展示，所以需要在组件中你想展示那个标签体的位置书写一个插槽&lt;slot&gt;&lt;&#x2F;slot&gt; 简单来说就是挖个坑，等待着组件的使用者往里面跳 但这些被丢进坑里的标签都是在使用者处定义的（解析完后才传递给组件），正所谓解铃还须系铃人，就我个人而言，样式在使用者处书写更为合适，父组件的优先级高于子组件 父组件 子组件 具名插槽当你想在不同插槽里放不同的东西，你不能直接写两个插槽，Vue默认会在解析完后全部放入同一个slot中，因为有两个slot。所以会出现两份内容，这个时候就需要具名插槽了。 具名插槽，顾名思义，就是给插槽一个name属性，并且在父组件对应的标签中添加一个v-slot属性，值为想放进去的那个插槽的name值 父组件 子组件 作用域插槽理解：数据在组件自身，但根据数据生成的结构需要组件的使用者来决定 假设子组件category具有user对象数据 父组件 子组件 在这里，父组件对子组件进行了一次传参，只不过传参与参数的接受仅仅局限于插槽之间 绑定在 &lt;slot&gt; 元素上的 attribute 被称为插槽 prop，而在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps 也就是说，子组件用:user=&quot;user&quot;将user对象绑定在了slotProps上，然后传递了过去，父组件则用slotProps.user.firstName的方式接收到了。 注意，这并不意味着作用域插槽可以用于子组件→父组件传递数据，实际逻辑为父组件→（需求子组件数据）→（发送请求）→（子组件绑定数据传输到父组件）→（父组件渲染）→（插入到子组件）→子组件。整体仍然是父组件传递数据到子组件"},{"title":"Vuex","date":"2023-03-28T12:38:51.000Z","url":"/2023/03/28/Vuex/","categories":[["undefined",""]],"content":"Vuex概念Vuex是一个专门为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态（数据）。 简单来说，Vuex是在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写)，也是一种组件间通信的方式，且适用于任意组件间通信 何时使用当多个组件需要共享数据 多个组件依赖于同一状态 来自不同组件的行为需要变更同一状态 原理图分析 State：vuex管理的状态对象（数据对象），它应该是唯一的 actions：为一个对象，包含多个响应用户动作的回调函数 在组件中使用$store.dispatch(&#39;对应的 action 回调名&#39;)触发actions中的回调 通过commit()来触发 mutation 中函数的调用，间接更新 state 可以包含异步代码（定时器，ajax等） mutations：是一个对象，包含多个直接更新 state 的方法 在 action 中使用 commit(&#39;对应的 mutations 方法名&#39;)触发 mutations 中的方法 不能写异步代码、只能单纯的操作 state Vuex的使用 在每个组件和vm身上都会有$store.state属性，我们可以从中获得state中的数据 若没有网络请求或其它业务逻辑，组件中也可以越过actions，即不写dispatch,直接编写commit 创建store文件夹并在其中创建index.js文件 在main.js文件里面引入并配置 getters可以理解为一个公用的计算属性 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工 在index.js中追加getters配置 组件中读取数据：$store.getters.bigSum map方法需要通过import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#39;vuex&#39;引入 mapState当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余，而mapState辅助函数帮助我们映射state中的数据为计算属性 在使用时，就不需要写$store.state.sum了，直接写sum mapGettersmapGetters方法用于帮助我们映射getters中的数据为计算属性 mapActionsmapActions方法用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数 对比： 原始 &#96;&#96;&#96;vue&#x2F;&#x2F;原始 &lt;button @click&#x3D;”incrementOdd”&gt;当前求和为奇数再加&lt;button @click&#x3D;”incrementWait”&gt;等一等再加 … methods: {incrementOdd(){this.$store.dispatch(‘jiaOdd’,this.n)},incrementWait(){this.$store.dispatch(‘jiaWait’,this.n)}, mapMutationsmapMutations方法用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数 对比：（1）原始 （2）使用mapMutations后 若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。 Vuex模块化 + namespace 目的：让代码更好维护，让多种数据分类更加明确 修改index.js 开启命名空间后，组件中读取state数据： 开启命名空间后，组件中能够读取getters数据： 开启命名空间后，组件中调用dispatch 开启命名空间后，组件中调用commit "},{"title":"监视属性","date":"2023-03-27T15:22:03.000Z","url":"/2023/03/27/%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7/","categories":[["undefined",""]],"content":"监视属性watch: 当监视的属性变化时，回调函数自动使用，进行相关操作 被监视的属性必须存在才能监视！ 监视属性的两种写法： new Vue时传入watch配置（需要一开始就知道监视的对象） 通过vm.$watch监视（后续发现的需要监视的对象） 监视属性能开启异步任务 computed和watch之间的区别： computed能完成的，watch都能完成 watch能完成的功能，computed不一定能完成，例如：watch能执行异步操作 两个重要的小原则： 所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象 所有不被Vue所管理的函数（定时器的回调函数，ajax的回调函数等），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象 深度监视： Vue中的watch默认不监测对象内部值的改变（一层） 配置deep:true可以监测对象内部值得改变（多层） 备注： Vue自身可以监测对象内部值的改变 使用watch时根据数据的具体结构，决定是否采用深度监视 代码演示："},{"title":"计算属性","date":"2023-03-26T06:26:53.000Z","url":"/2023/03/26/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/","categories":[["undefined",""]],"content":"计算属性定义：​ 要用的属性不存在，要通过已有属性计算得来 原理：​ 底层借助了Object.defineProperty方法提供的getter和setter get函数什么时候执行： 初次读取时会执行一次 当依赖的数据发生改变时会被再次调用 优势：​ 与methods事件相比，内部有缓存机制（复用），效率更高，调试方便 备注： 计算属性最终会出现在vm上，直接读取使用即可 计算属性中不能开启异步任务 "},{"title":"各种 v- 指令","date":"2023-03-19T14:03:36.000Z","url":"/2023/03/19/%E5%90%84%E7%A7%8D-v-%E6%8C%87%E4%BB%A4/","categories":[["undefined",""]],"content":"指令语法功能：​ 用于解析标签（包括：标签属性、标签体内容、绑定事件…..） 事件绑定v-on​ 用于绑定事件，例： ​ v-on可以简写为@，即：v-on:事件名 简写为 @事件名。 ​ @click&#x3D;”demo($event)” 可以传参，并且不会丢失事件对象 ​ v-on&#x3D;”{事件名：方法名，事件名：方法名，…..}” 来绑定多个事件 数据绑定v-bind​ 单向数据绑定，它是为标签里的某个属性绑定值用的，例： ​ v-bind可以简写为 : ，即：v-bind:href&#x3D;”xxx” 简写为 :href&#x3D;”xxx” v-model​ 双向数据绑定，只能应用在表单类元素（如：input、select等） ​ v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。 循环渲染v-for​ 遍历 遍历普通数组​ 语法 : v-for&#x3D;”(item,index) in array” ​ item : 数组中的每一项 ​ index : 索引值 ​ 如果只需要第一个参数item ,index可以不写,括号可以省略 遍历对象数组​ 语法 : v-for&#x3D;”(item,index) in array” ​ item : 数组中的每一项(每一个对象) ​ index : 索引值 ​ 如果只需要第一个参数item ,index可以不写,括号可以省略 遍历对象​ 语法 : v-for&#x3D;”(value,item,index) in obj” ​ value: 属性值 ​ item : 属性名 ​ index : 索引值 key的内部原理 虚拟DOM中key的作用key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下： 对比规则(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM（数据不同的地方），随后替换掉页面中之前的真实 DOM。(2).旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面。 用index作为key可能会引发的问题 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。 如果结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。 开发中如何选择key? 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。 条件渲染v-show​ 条件渲染，v-show指令通过改变元素的css属性（display）来决定元素是显示还是隐藏。 ​ v-show &#x3D; false时，相当于设置了样式的display为none v-if v-else-if v-else​ 条件渲染，与v-show类似，唯一不同的是，当v-if &#x3D; false时，直接删掉DOM结构 ​ v-else-if和v-else正常用，但是中间不能被打断 渲染文本v-text​ 用于将数据填充到标签中，作用于插值语法表达式类似，但是没有闪动问题 （如果数据中有HTML标签会将 html标签一并输出 ） 注意： v-text会把解析到为文本完全替换掉标签里的内容 不能解析字符串，v-text会把所有的字符串都当成正常的文本解析，不会当成标签，即使你的data里的str数据中有标签结构 v-html 作用：向指定节点中渲染包含html结构的内容。 与插值语法的区别： v-html会替换掉节点中所有的内容，则不会。 v-html可以识别html结构。 严重注意：v-html有安全性问题！！！！ 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。 一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！ 其它指令v-cloak指令（没有值）： 本质是一个特殊属性，Vue实例创建完毕并接管容易后，会删掉v-cloak属性 使用CSS配个v-cloak可以解决网速慢时页面展示出的问题 v-once指令（没有值）： 所在节点在初次动态渲染后，就视为静态内容了 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能 v-pre指令： 让Vue跳过其所在节点的编译过程 可以利用他跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译 "},{"title":"Vue初步","date":"2023-03-19T13:42:18.000Z","url":"/2023/03/19/Vue%E5%88%9D%E6%AD%A5/","categories":[["undefined",""]],"content":"初识Vue 想要让Vue工作，首先得创建一个Vue实例，且要传入一个配置对象 容器里面的代码依然符合html规范，只不过混入了一些特殊的Vue语法，代码被称为【Vue模板】 容器和Vue实例一一对应 真实开发中只有一个Vue实例，并且会配合着组件一起使用 插值语法中的xxx要书写js表达式，且xxx会自动读取到data中的属性 一旦data中的数据发生改变，模板中用到该数据的地方也会自动更新 如何找到容器通过容器id来让当前Vue实例和容器建立联系，值通常为css选择器字符串 MVVM模型这是Vue框架的构建思路 Model：数据 View：视图 ViewModel：Vue实例vm 最核心的就是 ViewModel，ViewModel 包含 DOM Listeners 和 Data Bindings。 从Model 到 View 的映射，也就是 Data Bindings，这样可以大量省略我们手动 update View 的代码和时间 从 View 到 Model 的事件监听，也就是 DOM Listeners，这样我们的 Model 就会随着 View 触发事件而改变 MVVM思想有两个方向一是将模型转换成视图，即将后端传递的数据转换成看到的页面。实现方式是：数据绑定。 二是将视图转换成模型，即将看到的页面转换成后端的数据。实现的方式是：DOM 事件监听。 这两个方向都实现的，就称为数据的双向绑定。"},{"title":"Vue框架的基本使用","date":"2023-03-19T13:41:41.000Z","url":"/2023/03/19/Vue%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","categories":[["undefined",""]],"content":"Data属性​ 本质上其实是一个返回值为对象的函数，Vue通过其返回值中对象的数据来进行对页面的数据渲染，一般都是需要用到 插值语法，一旦data中的数据发生改变，那么用到该数据的地方也会自动更新 注意：​ data有两种写法，最好采用函数的写法（避免组件复用时，数据存在引用关系导致组件相互间的数据连锁变化），由vue管理的函数不要写成箭头函数，否则this指向的就不是VueComponent实例对象（当前组件对象） Methods属性​ 本质上就是一个名为Methods的对象，Vue所做的就是在我们指定的事件下调用其中的方法 Vue事件 事件的基本使用： 使用 v-on : xxx 或 @xx 绑定事件，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，不要使用箭头函数！否则this就不是vm了 methods中配置的函数，都是被Vue管理的函数，this的指向是vm或组件实例对象 @click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参 Vue中的事件修饰符： prevent： 阻止默认事件（常用） stop：阻止事件冒泡（常用） once：事件只触发一次（常用） capture：使用事件的捕获模式 self：只有event.target是当前操作的元素时才触发 passive：事件的默认行为立即执行，无需等待事件回调执行完毕 修饰符能够链式调用 键盘事件 Vue中常用的按键别名： 回车 &#x3D;&gt; enter 删除 &#x3D;&gt; delete（捕获“删除”和“退格”键） 退出 &#x3D;&gt; esc 空格 &#x3D;&gt; space 换行 &#x3D;&gt; tab（特殊，必须配合keydown去使用） 上 &#x3D;&gt; up 下 &#x3D;&gt; down 左 &#x3D;&gt; left 右 &#x3D;&gt; right Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名） 系统修饰键(用法特殊)：crtl、alt、shift、meta(win)​ (1).配合keyup使用：按下修饰键的同时，再按下其它键，随后释放其它键，事件才被触发 ​ (2).配合keydown使用：正常触发事件 Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键名 Computed(计算属性)要用的属性不存在，要通过已有属性计算得来时，要用的属性就书写在这个对象中。 原理：底层借助了Object.defineProperty方法提供的getter和setter get函数什么时候执行： 初次读取时会执行一次 当依赖的数据发生改变时会被再次调用 优势：​ 与methods事件相比，内部有缓存机制（复用），效率更高，调试方便 备注： 计算属性最终会出现在vm上，直接读取使用即可 计算属性中不能开启异步任务 Watch(监视属性) 当监视的属性变化时，回调函数自动使用，进行相关操作 被监视的属性必须存在才能监视！ 监视属性的两种写法： new Vue时传入watch配置（需要一开始就知道监视的对象） 通过vm.$watch监视（后续发现的需要监视的对象） 监视属性能开启异步任务 computed和watch之间的区别： computed能完成的，watch都能完成 watch能完成的功能，computed不一定能完成，例如：watch能执行异步操作 两个重要的小原则： 所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象 所有不被Vue所管理的函数（定时器的回调函数，ajax的回调函数等），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象 深度监视： Vue中的watch默认不监测对象内部值的改变（一层） 配置deep:true可以监测对象内部值的改变（多层） 备注： Vue自身可以监测对象内部值的改变 使用watch时根据数据的具体结构，决定是否采用深度监视 "}]